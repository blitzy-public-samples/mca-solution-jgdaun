/**
 * @file PDF Utility Functions
 * This file provides utility functions for generating, manipulating, and processing PDF documents
 * within the frontend application, implementing document processing flow requirements.
 * @version 1.0.0
 */

// Third-party imports with versions
import { PDFDocument, StandardFonts, rgb } from 'pdf-lib'; // v1.17.1
import blobStream from 'blob-stream'; // v0.1.3

// Internal imports
import { formatCurrency } from './format';
import { validateDocument } from './validation';
import { Document, DocumentStatus, DocumentMetadata } from '../types/document';

// Constants for PDF generation
const PAGE_WIDTH = 612; // 8.5 inches at 72 DPI
const PAGE_HEIGHT = 792; // 11 inches at 72 DPI
const MARGIN = 50;
const COMPANY_NAME = 'Document Processing System';
const FOOTER_TEXT = 'Generated by Document Processing System';

/**
 * Generates a PDF document from given document data with proper formatting and validation.
 * Implements requirements from document_processing_flow and main_dashboard_components.
 * 
 * @param documentData - The document data to be used for PDF generation
 * @returns Promise resolving to Uint8Array representing the PDF document
 */
export const generatePdf = async (documentData: Document): Promise<Uint8Array> => {
  try {
    // Validate document data before processing
    const validationResult = validateDocument(documentData);
    if (!validationResult.success) {
      throw new Error(`Document validation failed: ${validationResult.message}`);
    }

    // Create a new PDF document
    const pdfDoc = await PDFDocument.create();
    
    // Set document metadata
    pdfDoc.setTitle(documentData.fileName);
    pdfDoc.setAuthor(COMPANY_NAME);
    pdfDoc.setCreationDate(new Date());
    pdfDoc.setModificationDate(new Date());

    // Add the first page
    const page = pdfDoc.addPage([PAGE_WIDTH, PAGE_HEIGHT]);
    const { width, height } = page.getSize();

    // Embed the standard font
    const font = await pdfDoc.embedFont(StandardFonts.Helvetica);
    const boldFont = await pdfDoc.embedFont(StandardFonts.HelveticaBold);

    // Draw header
    page.drawText(COMPANY_NAME, {
      x: MARGIN,
      y: height - MARGIN,
      size: 24,
      font: boldFont,
      color: rgb(0, 0, 0),
    });

    // Draw document information
    const startY = height - MARGIN - 60;
    const lineHeight = 25;
    let currentY = startY;

    // Document metadata section
    page.drawText('Document Information:', {
      x: MARGIN,
      y: currentY,
      size: 14,
      font: boldFont,
    });
    currentY -= lineHeight;

    const metadataFields = [
      { label: 'Document ID:', value: documentData.id },
      { label: 'Type:', value: documentData.type },
      { label: 'Status:', value: documentData.status },
      { label: 'Upload Date:', value: documentData.uploadedAt.toLocaleDateString() },
      { label: 'Classification:', value: documentData.classification },
    ];

    for (const field of metadataFields) {
      page.drawText(`${field.label} ${field.value}`, {
        x: MARGIN,
        y: currentY,
        size: 12,
        font: font,
      });
      currentY -= lineHeight;
    }

    // Draw extracted data if available
    if (documentData.metadata.extractedData) {
      currentY -= lineHeight; // Add extra spacing
      page.drawText('Extracted Data:', {
        x: MARGIN,
        y: currentY,
        size: 14,
        font: boldFont,
      });
      currentY -= lineHeight;

      for (const [key, value] of Object.entries(documentData.metadata.extractedData)) {
        // Format currency values if applicable
        const displayValue = typeof value === 'number' 
          ? formatCurrency(value)
          : String(value);

        page.drawText(`${key}: ${displayValue}`, {
          x: MARGIN,
          y: currentY,
          size: 12,
          font: font,
        });
        currentY -= lineHeight;
      }
    }

    // Add footer with page numbers
    const pageCount = pdfDoc.getPageCount();
    for (let i = 0; i < pageCount; i++) {
      const page = pdfDoc.getPage(i);
      page.drawText(`${FOOTER_TEXT} | Page ${i + 1} of ${pageCount}`, {
        x: MARGIN,
        y: MARGIN,
        size: 10,
        font: font,
        color: rgb(0.5, 0.5, 0.5),
      });
    }

    // Serialize the PDF document
    return await pdfDoc.save();
  } catch (error) {
    throw new Error(`PDF generation failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
};

/**
 * Merges multiple PDF documents into a single PDF file.
 * Implements document processing flow requirements for combining multiple documents.
 * 
 * @param pdfDocuments - Array of PDF documents as Uint8Array to merge
 * @returns Promise resolving to merged PDF document as Uint8Array
 */
export const mergePdfs = async (pdfDocuments: Uint8Array[]): Promise<Uint8Array> => {
  try {
    if (!pdfDocuments.length) {
      throw new Error('No PDF documents provided for merging');
    }

    // Create a new PDF document for merging
    const mergedPdf = await PDFDocument.create();
    
    // Set metadata for merged document
    mergedPdf.setTitle('Merged Document');
    mergedPdf.setAuthor(COMPANY_NAME);
    mergedPdf.setCreationDate(new Date());
    mergedPdf.setModificationDate(new Date());

    // Process each document
    for (let i = 0; i < pdfDocuments.length; i++) {
      // Load the source document
      const sourceDoc = await PDFDocument.load(pdfDocuments[i]);
      
      // Copy all pages from source to merged document
      const pages = await mergedPdf.copyPages(sourceDoc, sourceDoc.getPageIndices());
      pages.forEach(page => {
        mergedPdf.addPage(page);
      });
    }

    // Add page numbers and merge indicators to all pages
    const font = await mergedPdf.embedFont(StandardFonts.Helvetica);
    const pageCount = mergedPdf.getPageCount();

    for (let i = 0; i < pageCount; i++) {
      const page = mergedPdf.getPage(i);
      const { width, height } = page.getSize();

      // Add merge indicator and page numbers
      page.drawText(`Merged Document | Page ${i + 1} of ${pageCount}`, {
        x: MARGIN,
        y: MARGIN,
        size: 10,
        font: font,
        color: rgb(0.5, 0.5, 0.5),
      });
    }

    // Serialize the merged PDF document
    return await mergedPdf.save();
  } catch (error) {
    throw new Error(`PDF merging failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
};

// Export named functions
export {
  generatePdf,
  mergePdfs
};